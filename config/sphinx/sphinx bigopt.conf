#
# Minimal Sphinx configuration sample (clean, simple, functional)
#

source base
{
	type			= mysql

	sql_host		= mysql
	sql_user		= root
	sql_pass		= 7212104
	sql_db			= bigopt
	sql_port		= 3306	# optional, default is 3306
}


###---------- BIGOPT

source goods : base
{

	sql_query_pre 		= SET NAMES utf8
	sql_query_range 	= SELECT MIN(id), MAX(id) FROM goods
	sql_range_step 		= 500
	
	sql_query = \
		select \
			id, \
			name, \
			keywords, \
			about, \
			'' as nrTitle, \
			artikyl, \
			idprojekt, \
			marketrub, \
			UNIX_TIMESTAMP(data) as data, \
			if(price='' or price='0', 0, 1) as hasPrice, \
			if(price='' or price='0', 0, price) as price, \
			dropPrice, \
			rrPrice, \
			(select projekt.pay as pay from projekt where projekt.id = goods.idprojekt) as pay, \
			pay as goodsPay, \
			firmPay, \
			firmShowStatus as firmShowStatus, \
			1000 as countGoods, \
			1 as ind \
		from goods \
		where  id >= $start AND id <= $end \
		ORDER BY id ASC 
		
	sql_attr_uint 		= idprojekt
	sql_attr_uint 		= ind
	sql_attr_timestamp 	= data
	sql_attr_uint 		= hasPrice
	sql_attr_uint 		= price
	sql_attr_uint 		= dropPrice
	sql_attr_uint 		= rrPrice
	sql_attr_uint 		= pay
	sql_attr_uint 		= goodsPay
	sql_attr_uint 		= countGoods
	sql_attr_uint 		= marketrub
	sql_attr_uint 		= firmPay
	sql_attr_string 	= firmShowStatus
	sql_attr_multi 		= uint aNrId from query; SELECT goods.id, nr.parent FROM goods LEFT JOIN nr on nr.id = goods.marketrub WHERE goods.marketrub != 0 AND nr.parent != 0 UNION SELECT goods.id, goods.marketrub FROM goods WHERE goods.marketrub != 0 
} 

source nr : base
{

	sql_query_pre 		= SET NAMES utf8
	sql_query_range 	= SELECT MIN(id), MAX(id) FROM `nr` 
	sql_range_step 		= 500
	
	sql_query = \
		select \
			id, \
			name_rus as nrTitle, \
			'' as name, \
			'' as keywords, \
			'' as about, \
			UNIX_TIMESTAMP(now()) as data, \
			1 as hasPrice, \
			0 as price, \
			1 as pay, \
			cg as countGoods, \
			'show' as firmShowStatus, \
			'publicated' as state, \
			2 as ind \
		from  \
			nr \
		where  \
			id >= $start AND  \
			id <= $end \
		ORDER BY id ASC 
		
#	sql_query = \
#		select  \
#			ttt.id, \
#			ttt.name as nrTitle, \
#			'' as name, \
#			'' as keywords, \
#			'' as about, \
#			UNIX_TIMESTAMP(now()) as data, \
#			1 as hasPrice,  \
#			0 as price,  \
#			1 as pay,  \
#			ttt.countGoods, \
#			'show' as firmShowStatus, \
#			2 as ind  \
#		from ( \
#			select \
#				nr2.id as id, \
#				nr2.name_rus as name, \
#				count(*) as countGoods \
#			from goods as g  \
#			left join nr on g.marketrub = nr.id \
#			left join nr as nr2 on nr.parent = nr2.id \
#			where nr2.id is not null and nr2.id != 0 \
#			group by nr2.id \
#			union \
#			select  \
#				nr.id as id,  \
#				nr.name_rus as name,  \
#				count(*) as countGoods \
#			from goods as g  \
#			left join nr on g.marketrub = nr.id \
#			left join nr as nr2 on nr.parent = nr2.id \
#			where nr.id is not null and nr2.id != 0\
#			group by nr.id \
#		) as ttt \
#		where id >= $start AND id <= $end \
#		ORDER BY id ASC  
		
	sql_attr_uint 		= ind
	sql_attr_timestamp 	= data
	sql_attr_uint 		= hasPrice
	sql_attr_uint 		= price
	sql_attr_uint 		= pay
	sql_attr_uint 		= countGoods
	sql_attr_string		= firmShowStatus
}

source goodscat : base
{

	sql_query_pre 		= SET NAMES utf8
	sql_query_range 	= SELECT MIN(id), MAX(id) FROM goodscat
	sql_range_step 		= 200
	
	sql_query = \
		select  \
			ttt.id,  \
			ttt.name,  \
			ttt.label as keywords,	 \
			UNIX_TIMESTAMP(now()) as `data`,  \
			'1' as `hasPrice`,   \
			'0' as `price`, \
			(select projekt.pay as pay from projekt where projekt.id = ttt.idprojekt) as pay,  \
			(select count(*) from goods left join goodscat on goods.rub = goodscat.id where goodscat.id = ttt.id or goodscat.parent = ttt.id) as countGoods,  \
			ttt.idprojekt,   \
			'show' as firmShowStatus, \
			3 as ind   \
		from goodscat as ttt \
		where ttt.id >= $start AND ttt.id <= $end \
		ORDER BY ttt.id ASC 
		
#	sql_query = \
#		select \
#			ttt.id, \
#			ttt.name, \
#			ttt.label as keywords,	\
#			UNIX_TIMESTAMP(now()) as data, \
#			1 as hasPrice,  \
#			0 as price,  \
#			(select projekt.pay as pay from projekt where projekt.id = ttt.idprojekt) as pay, \
#			ttt.countGoods, \
#			idprojekt as idprojekt,  \
#			'show' as firmShowStatus, \
#			3 as ind  \
#		from ( \
#			select  \
#				nr2.id as id,  \
#				nr2.name as name, \
#				nr2.label as label,\
#				count(*) as countGoods, \
#				nr2.idprojekt as idprojekt \
#			from goods as g  \
#			left join goodscat as nr on g.rub = nr.id \
#			left join goodscat as nr2 on nr.parent = nr2.id \
#			where nr2.id is not null and nr2.id != 0 \
#			group by nr2.id \
#			union \ 
#			select  \
#				nr.id as id,  \
#				nr.name as name, \
#				nr.label as label, \
#				count(*) as countGoods, \
#				nr.idprojekt as idprojekt \
#			from goods as g  \
#			left join goodscat as nr on g.rub = nr.id \
#			left join goodscat as nr2 on nr.parent = nr2.id \
#			where nr.id is not null and nr.id != 0 \
#			group by nr.id \
#		) as ttt \
#		where id >= $start AND id <= $end  \
#		ORDER BY id ASC 
		
	sql_attr_uint 		= ind
	sql_attr_timestamp 	= data
	sql_attr_uint 		= hasPrice
	sql_attr_uint 		= price
	sql_attr_uint 		= pay
	sql_attr_uint 		= countGoods
	sql_attr_uint 		= idprojekt
	sql_attr_string		= firmShowStatus
}


source informer : base
{

	sql_query_pre 		= SET NAMES utf8
	sql_query_range 	= SELECT MIN(id), MAX(id) FROM `informers` 
	sql_range_step 		= 500
	
	sql_query = \
		select \
			id, \
			name, \
			4 as ind\
		from informers \
		where status = 1 and id >= $start AND id <= $end \
		ORDER BY id ASC 
		
	sql_attr_uint 		= ind
}

source projekt : base
{

	sql_query_pre 		= SET NAMES utf8
	sql_query_range 	= SELECT MIN(id), MAX(id) FROM `projekt` 
	sql_range_step 		= 500
	
	sql_query = \
		select \
			id, \
			name, \
			whoare, \
			searchworld, \
			pay, \
			type, \
			city, \
			showStatus, \
			5 as ind\
		from projekt \
		where id >= $start AND id <= $end \
		ORDER BY id ASC 
		
	sql_attr_uint 		= ind
	sql_attr_uint 		= pay
	sql_attr_uint 		= type
	sql_attr_uint 		= city
	sql_attr_string		= showStatus
	sql_attr_multi 		= uint aNrId from query; SELECT idprojekt, rub \
												FROM projekt_rub \
												union \
												SELECT projekt_rub.idprojekt, nr.parent as rub \
												FROM projekt_rub \
												LEFT JOIN nr on nr.id = projekt_rub.rub \
												where nr.parent != 0 
	sql_attr_multi 		= uint aTagId from query; SELECT firmId, firmTagId \
												FROM firmTagList 
}

source wall : base
{ 

	sql_query_pre 		= SET NAMES utf8
	sql_query_range 	= SELECT MIN(id), MAX(id) FROM `wall`
	sql_range_step 		= 500
	
	sql_query = \
		select \
			id, \
			target, \
			firmId, \
			userId, \
			UNIX_TIMESTAMP(date) as date, \
			forMy, \
			text \
		from wall \
		where id >= $start AND id <= $end \
		ORDER BY id ASC 
		
	sql_field_string	= target
	sql_attr_uint 		= firmId
	sql_attr_uint 		= userId
	sql_attr_timestamp	= date
	sql_attr_uint 		= forMy
}

###---------- BIGOPT

###---------- BIGOPT Start indexes

index goods
{
	source 			= goods
    path 			= /var/lib/sphinx/goods
	# Ukrainian chars
    charset_table 	= 0..9, U+002E, _, A..Z->a..z, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+404->U+454, U+454, U+406->U+456, U+456, U+407->U+457, U+457, U+490->U+491, U+491, U+401->U+435, U+451->U+435, U+002D
    morphology 		= stem_enru
    min_word_len 	= 2
	html_strip 		= 1
}

index nr
{
	source 			= nr
    path 			= /var/lib/sphinx/nr
    morphology 		= stem_enru
    min_word_len 	= 3
	html_strip 		= 0
}

index goodscat
{
	source 			= goodscat
    path 			= /var/lib/sphinx/goodscat
	# Ukrainian chars
    charset_table 	= 0..9, _, A..Z->a..z, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+404->U+454, U+454, U+406->U+456, U+456, U+407->U+457, U+457, U+490->U+491, U+491, U+401->U+435, U+451->U+435, U+002D
    morphology 		= stem_enru
    min_word_len 	= 3
	html_strip 		= 0
}

index informer
{
	source 			= informer
    path 			= /var/lib/sphinx/informer
	# Ukrainian chars
    charset_table 	= 0..9, _, A..Z->a..z, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+404->U+454, U+454, U+406->U+456, U+456, U+407->U+457, U+457, U+490->U+491, U+491, U+401->U+435, U+451->U+435, U+002D
    morphology 		= stem_enru
    min_word_len 	= 3
	html_strip 		= 0
}

index projekt
{
	source 			= projekt
    path 			= /var/lib/sphinx/projekt
	# Ukrainian chars
    charset_table 	= 0..9, _, A..Z->a..z, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+404->U+454, U+454, U+406->U+456, U+456, U+407->U+457, U+457, U+490->U+491, U+491, U+401->U+435, U+451->U+435, U+002D
    morphology 		= stem_enru
    min_word_len 	= 3
	html_strip 		= 0
}

index wall
{
	source 			= wall
    path 			= /var/lib/sphinx/wall
	# Ukrainian chars
    charset_table 	= 0..9, _, A..Z->a..z, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+404->U+454, U+454, U+406->U+456, U+456, U+407->U+457, U+457, U+490->U+491, U+491, U+401->U+435, U+451->U+435, U+002D
    morphology 		= stem_enru
    min_word_len 	= 3
	html_strip 		= 0
}

###---------- BIGOPT End indexes


index testrt
{
	type			= rt
	rt_mem_limit	= 128M
	path			= /var/lib/sphinx/testrt
}


indexer
{
	mem_limit		= 1024M
}


searchd
{
	listen			= 9312
	listen			= 9306:mysql41
	log				= /var/log/sphinx/searchd.log
	query_log		= /var/log/sphinx/query.log
	read_timeout	= 5
	max_children	= 30
	pid_file		= /var/run/sphinx/searchd.pid
	seamless_rotate	= 1
	preopen_indexes	= 1
	unlink_old		= 1
	workers			= threads # for RT to work
	binlog_path		= /var/lib/sphinx/
}